# Docstrings for the hse module

[hse.KVDB_VERSION_STRING]
__doc__ = """
A string representing the HSE KVDB libary version

The version string starts with a numeric sequence (e.g., 1.7.0) and then, depending
on the type of build may have additional information appended.
"""

[hse.KVDB_VERSION_TAG]
__doc__ = """
A string representing the HSE KVDB libary version tag

The version tag starts with a sequence (e.g., r1.9.0) and then, depending
on the type of build may have additional information appended.
"""

[hse.KVDB_VERSION_SHA]
__doc__ = """
A string representing the HSE KVDB library version commit hash

The version commit hash is a git commit hash
(e.g., b55fe07774d7cbc1492d7b8a47dc2c194cd3e24a).
"""

[hse.KvdbException]
__doc__ = """
Thrown when HSE encounters an error. Wrapper around `hse_err_t`.

Members:

returncode - error code returned by HSE
"""

[hse.Kvdb.close]
__doc__ = """
Close an open HSE KVDB

No client thread may enter the HSE KVDB API with the referenced KVDB after this
function starts. This function is not thread safe.
"""

[hse.Kvdb.init]
__doc__ = """
Initialize the HSE KVDB subsystem

This function initializes a range of different internal HSE structures. It must be
called before any other HSE functions are used. It is not thread safe and is
idempotent.
"""

[hse.Kvdb.fini]
__doc__ = """
Shutdown the HSE KVDB subsystem

This function cleanly finalizes a range of different internal HSE structures. It
should be called prior to application exit and is not thread safe. After it is
invoked (and even before it returns), calling any other HSE functions will result in
undefined behavior. This function is not thread safe.
"""

[hse.Kvdb.make]
__doc__ = """
Create a new KVDB instance within the named mpool

The mpool must already exist and the client must have permission to use the
mpool. This function is not thread safe.

Args:

mp_name - Mpool name in which the KVDB exists\\n
params - Configuration parameters
"""

[hse.Kvdb.open]
__doc__ = """
Open an HSE KVDB for use by the application

The KVDB must already exist and the client must have permission to use it. This
function is not thread safe.

Args:

mp_name - Mpool name in which the KVDB exists\\n
params - Configuration parameters
"""

[hse.Kvdb.get_names]
__doc__ = """
Get the names of the KVSs within the given KVDB

Key-value stores (KVSs) are opened by name. This function allocates a list of
strings, each containing the name of a KVS. This function is thread safe.
"""

[hse.Kvdb.kvs_make]
__doc__ = """
Create a new KVS within the referenced KVDB

If the KVS will store multi-segment keys then the parameter `pfx_len` should be set
to the desired key prefix length - see `hse.Params.set()` and related functions
below. Otherwise the param should be set to 0 (the default).  An error will result
if there is already a KVS with the given name.  This function is not thread safe.

Args:

kvs_name - KVS name
"""

[hse.Kvdb.kvs_drop]
__doc__ = """
Remove a KVS from the referenced KVDB

It is an error to call this function on a KVS that is open. This function is not
thread safe.

Args:

kvs_name - KVS name
"""

[hse.Kvdb.kvs_open]
__doc__ = """
Open a KVS in a KVDB

This function is not thread safe.

Args:

kvs_name - KVS name\\n
params - Parameters that affect how the KVS will function
"""

[hse.Kvdb.sync]
__doc__ = """
Flush data in all of the referenced KVDB's KVSs to stable media and return
"""

[hse.Kvdb.flush]
__doc__ = """
Initiate data flush in all of the referenced KVDB's KVSs
"""

[hse.Kvdb.compact]
__doc__ = """
Request a data compaction operation

In managing the data within an HSE KVDB, there are maintenance activities that occur
as background processing. The application may be aware that it is advantageous to do
enough maintenance now for the database to be as compact as it ever would be in
normal operation. To achieve this, the client calls this function in the following
fashion::

    kvdb.compact(samp_lwm=True)

To cancel an ongoing compaction request for a KVDB::

    kvdb.compact(cancel=True)

See the property `kvdb.compact_status`. This function is thread safe.

Args:

cancel - To cancel an ongoing compaction request for a KVDB\\n
samp_lwm - To perform compaction to its fullest extent
"""

[hse.Kvdb.compact_status]
__doc__ = """
Get status of an ongoing compaction activity

The caller can examine the properties of the `KvdbCompactStatus` class to determine
the current state of maintenance compaction. This function is thread safe.
"""

[hse.Kvdb.txn_alloc]
__doc__ = """
Allocate transaction object

This object can and should be re-used many times to avoid the overhead of
allocation. This function is thread safe.
"""

[hse.Kvs.close]
__doc__ = """
Close an open KVS

No client thread may enter the HSE KVDB API with the referenced KVS after this
function starts. This function is not thread safe.
"""

[hse.Kvs.put]
__doc__ = """
Put a KV pair into KVS

If the key already exists in the KVS then the value is effectively overwritten. The
key length must be in the range [1, `hse.KVS_KLEN_MAX`] while the value length must be
in the range [0, `hse.KVS_VLEN_MAX`]. See the section on transactions for information
on how puts within transactions are handled. This function is thread safe.

The HSE KVDB attempts to maintain reasonable QoS and for high-throughput clients this
results in very short sleep's being inserted into the put path. For some kinds of
data (e.g., control metadata) the client may wish to not experience that delay. For
relatively low data rate uses, the caller can set the priority parameter
for an `hse.Kvs.put()` call. Care should be taken when doing so to ensure that the
system does not become overrun. As a rough approximation, doing 1M priority puts per
second marked as PRIORITY is likely an issue. On the other hand, doing 1K small puts
per second marked as PRIORITY is almost certainly fine.

Args:

key - Key to put into KVS\\n
value - Value associated with key\\n
priority - Operation won't be throttled\\n
txn - Transaction context
"""

[hse.Kvs.get]
__doc__ = """
Retrieve the value for a given key from KVS

If the key exists in the KVS then the return value is not None. See the section
on transactions for information on how gets within transactions are handled. This
function is thread safe.

Args:

key - Key to get from KVS\\n
txn - Transaction context\\n
buf - Buffer to store the value in, defaults to `hse.KVS_VLEN_MAX`
"""

[hse.Kvs.delete]
__doc__ = """
Delete the key and its associated value from KVS

It is not an error if the key does not exist within the KVS. See the section on
transactions for information on how deletes within transactions are handled. This
function is thread safe.

Args:

key - Key to be deleted from KVS\\n
priority - Operation won't be throttled\\n
txn - Transaction context
"""

[hse.Kvs.prefix_delete]
__doc__ = """
Delete all KV pairs matching the key prefix from a KVS storing multi-segment keys

This interface is used to delete an entire range of multi-segment keys. To do this
the caller passes a filter with a length equal to the KVS's key prefix length. It is
not an error if no keys exist matching the filter. If there is a filtered iteration
in progress, then that iteration can fail if `hse.Kvs.prefix_delete()` is called with
a filter matching the iteration. This function is thread safe.

Args:

filt - Filter for keys to delete\\n
priority - Operation won't be throttled\\n
txn - Transaction context
"""

[hse.Kvs.cursor_create]
__doc__ = """
Creates a cursor used to iterate over a KVS

When cursors are created they are by default forward iterating. If the caller of
hse.Kvs.cursor_create() passes a reference to an initialized opspec with the
reverse paramater set, then a backwards (reverse sort order) iterating cursor
is created. A cursor's direction is determined when it is created and is immutable.

Cursors are of one of three types: (1) free, (2) transaction snapshot, and (3)
transaction bound. A cursor of type (1) is based on an ephemeral snapshot view of the
KVS at the time it is created. New data is not visible to the cursor until
`hse.KvsCursor.update()` is called on it. A cursor of type (2) takes on the
transaction's ephemeral snapshot but cannot see any of the mutations made by its
associated transaction. A cursor of type (3) is like type (2) but it always can see
the mutations made by the transaction. Calling `hse.KvsCursor.update()` on a cursor of
types (2) and (3) without changing the parameter fields is a no-op. This
function is thread safe.

The cursor parameters shape the type and behavior of the cursor created. The
parameters within cursor functions are independent.

    - To create a cursor of type (1):
        - Pass no optional arguments

    - To create a cursor of type (2):
        - Pass a transaction to the cursor

    - To create a cursor of type (3):
        - Pass a transaction to the cursor with `bind_txn` set

The primary utility of the prefix filter mechanism is to maximize the efficiency of
cursor iteration on a KVS with multi-segment keys. For that use case, the caller
should supply a filter whose length is greater than or equal to the KVS key prefix
length. The caller can also provide a filter that is shorter than the key prefix
length or can perform this operation on a KVS whose key prefix length is zero. In all
cases, the cursor will be restricted to keys matching the given prefix filter.

When a transaction associated with a cursor of type (3) commits or aborts, the state
of the cursor becomes unbound, i.e., it becomes of type (1). What can be seen through
the cursor depends on whether it was created with the `static_view` parameter set.

If it was set, then the cursor retains the snapshot view of the transaction (for both
commit and abort). If it was not set then the view of the cursor is that of the
database at the time of the commit or abort. In the commit case, the cursor can see
the mutations of the transaction, if any. Note that this will make any other
mutations that occurred during the lifespan of the transaction visible as well.

Args:

filt - Iteration limited to keys matching this prefix filter\\n
reverse - Reverse cursor\\n
static_view - Bound cursor's view is static\\n
bind_txn - Cursor bound to transaction\\n
txn - Transaction context
"""

[hse.KvdbTxnState]
__doc__ = """
State a transaction could be in
"""

[hse.KvdbTxn]
__doc__ = """
The HSE KVDB provides transactions with operations spanning KVSs within a single
KVDB. These transactions have snapshot isolation (a specific form of MVCC) with the
normal semantics (see "Concurrency Control and Recovery in Database Systems" by PA
Bernstein).

One unusual aspect of the API as it relates to transactions is that the data object
that is used to hold client-level transaction state is allocated separately from the
transaction being initiated. As a result, the same object handle should be reused
again and again.

In addition, there is very limited coupling between threading and transactions. A
single thread may have many transactions in flight simultaneously. Also operations
within a transaction can be performed by multiple threads. The latter mode of
operation must currently restrict calls so that only one thread is actively
performing an operation in the context of a particular transaction at any particular
time.

The general lifecycle of a transaction is as follows:

                        +----------+
                        | INVALID  |
                        +----------+
                            |
                            v
                        +----------+
    +---------------->|  ACTIVE  |<----------------+
    |                 +----------+                 |
    |  +-----------+    |      |     +----------+  |
    +--| COMMITTED |<---+      +---->| ABORTED  |--+
        +-----------+                 +----------+

When a transaction is initially allocated, it starts in the INVALID state. When
`hse.KvdbTxn.begin()` is called with transaction in the INVALID, COMMITTED, or ABORTED
states, it moves to the ACTIVE state. It is an error to call the `hse.KvdbTxn.begin()`
function on a transaction in the ACTIVE state. For a transaction in the ACTIVE state,
only the functions `hse.KvdbTxn.commit()` or `hse.KvdbTxn.abort()` may be called (with the
last doing an abort prior to the free).

When a transaction becomes ACTIVE, it establishes an ephemeral snapshot view of the
state of the KVDB. Any data mutations outside of the transaction's context after that
point are not visible to the transaction. Similarly, any mutations performed within
the context of the transaction are not visible outside of the transaction unless and
until it is committed. All such mutations become visible atomically.
"""

[hse.KvdbTxn.begin]
__doc__ = """
Initiate transaction

The call fails if the transaction handle refers to an ACTIVE transaction. This
function is thread safe with different transactions.
"""

[hse.KvdbTxn.commit]
__doc__ = """
Commit all the mutations of the referenced transaction

The call fails if the referenced transaction is not in the ACTIVE state. This
function is thread safe with different transactions.
"""

[hse.KvdbTxn.abort]
__doc__ = """
Abort/rollback transaction

The call fails if the referenced transaction is not in the ACTIVE state. This
function is thread safe with different transactions.
"""

[hse.KvdbTxn.state]
__doc__ = """
Retrieve the state of the referenced transaction

This function is thread safe with different transactions.
"""

[hse.KvsCursor.destroy]
__doc__ = """
Destroy cursor

This function is thread safe.
"""

[hse.KvsCursor.items]
__doc__ = """
Convenience function to return an iterator over key/values in a KVS

Args:

max_count - Limit for the number of results
"""

[hse.KvsCursor.update]
__doc__ = """
Update a plain cursor or modify any cursor

This operation serves to either move the snapshot view forward for a type (1) cursor,
or to transition between being a type (1), type (2), and type (3) cursor.  That
includes toggling the state of the `static_view` parameter.  For example,
to "un-bind" a cursor from a transaction the caller may either set the `txn` parameter
to `None` or clear the `bind_txn` parameter. This function is thread safe
across disparate cursors.

Args:

reverse - Reverse cursor\\n
static_view - Bound cursor's view is static\\n
bind_txn - Cursor bound to transaction\\n
txn - Transaction context
"""

[hse.KvsCursor.seek]
__doc__ = """
Move the cursor to point at the key/value pair at or closest to `key`

The next `hse.KvsCursor.read()` will start at this point. This function is
thread safe across disparate cursors.

Args:

key - Key to find
"""

[hse.KvsCursor.seek_range]
__doc__ = """
Move the cursor to the closest match to key, gated by the given filter

Keys read from this cursor will belong to the closed interval defined by the given
filter: [`filt_min`, `filt_max`]. For KVSs storing multi-segment keys, performance
will be enhanced when the length of `filt_min` and `filt_max` are greater than or equal to
the KVS key prefix length. This function is thread safe across disparate cursors.

Note: this is only supported for forward cursors.

Args:

filt_min - Filter minimum\\n
filt_max - Filter maximum
"""

[hse.KvsCursor.read]
__doc__ = """
Iteratively access the elements pointed to by the cursor

Read a KV pair from the cursor, advancing the cursor past its current location. If
the cursor is at EOF, attempts to read from it will not change the state of the
cursor. This function is thread safe across disparate cursors.
"""

[hse.KvdbCompactStatus]
__doc__ = """
Contains infomation about the Kvdb's current compaction status including
`samp_lwm`, `samp_hwm`, `samp_curr`, `samp_active`, and `canceled`.
"""

[hse.KvdbCompactStatus.samp_lwm]
__doc__ = """
space amp low water mark (%)
"""

[hse.KvdbCompactStatus.samp_hwm]
__doc__ = """
space amp high water mark (%)
"""

[hse.KvdbCompactStatus.samp_curr]
__doc__ = """
current space amp (%)
"""

[hse.KvdbCompactStatus.active]
__doc__ = """
is an externally requested compaction underway
"""

[hse.KvdbCompactStatus.canceled]
__doc__ = """
was an externally requested compaction canceled
"""

[hse.Params.get]
__doc__ = """
Get configuration parameter

Obtain the value the parameter denoted by `key` is set to in the params object.
This function is not thread safe.

Args:

key - Target key
"""

[hse.Params.set]
__doc__ = """
Set configuration parameter

Set the parameter setting given by `key` to `value`. If the `key` or `value` is
invalid then the call will fail.

The following syntax is supported for keys:

kvdb.<param>           # param is set for the KVDB\\n
kvs.<param>            # param is set for all KVSs in the KVDB\\n
kvs.<kvs_name>.<param> # param is set for the named KVS

This function is not thread safe.

Args:

key - Target key\\n
value - Target value
"""

[hse.Params.create]
__doc__ = """
Create a params object

This function allocates an empty params object. This object can then be populated
through `hse.Params.from_file()`, `hse.Params.from_string()`, or via `hse.Params.set()`.
Usage of a given params object is not thread safe.
"""

[hse.Params.from_dict]
__doc__ = """
Parse params from a dictionary

This function takes a dictionary and transforms it, populating the
supplied params object. This function is not thread safe.

Args:

params - Configuration parameters
"""

[hse.Params.from_file]
__doc__ = """
Parse params from a file

This function takes a filename and parses it, populating the supplied params
object. If the file is not a valid params specification, the parsing will
fail. This function is not thread safe.

Args:

path - Path to configuration file
"""

[hse.Params.from_string]
__doc__ = """
Parse params from a string

This function takes a YAML string and parses it, populating the supplied params object. If
the string is not a valid params specification, the parsing will fail. This function is
not thread safe.

Args:

input - Input paramters in YAML format
"""

[limits]
__doc__ = """
Global Limits
"""

[limits.KVS_COUNT_MAX]
__doc__ = """
Maximum number of KVS's contained within one KVDB
"""

[limits.KVS_KLEN_MAX]
__doc__ = """
A common requirement for key length for the software above HSE KVDB is 1024.
Combined with a discriminant and (potentially) a chunk key, this pushes us to
1030 bytes keys. Looking at the packing for the on-media format for data, we
can have at most 3 keys of such large size in a 4k page. Lopping off 64-bytes
for other data, and we can have 3 keys of 1344 bytes.
"""

[limits.KVS_VLEN_MAX]
__doc__ = """
Max value length is 1MiB
"""

[limits.KVS_MAX_PFXLEN]
__doc__ = """
Max key prefix length
"""

[limits.KVS_NAME_LEN_MAX]
__doc__ = """
Max KVS name lengths
"""
